/**
 * Firebase Firestore Security Rules for MedFlow
 * 
 * Production-ready security rules with:
 * - Role-based access control for doctors and nurses
 * - Medical data protection and GDPR compliance
 * - Comprehensive data validation
 * - Audit logging and security monitoring
 * - Performance optimization
 * 
 * @author MedFlow Team
 * @version 2.0
 * @compliance GDPR, HIPAA-ready
 */

rules_version = '2';
service cloud.firestore {
  match /databases/{database}/documents {
    
    // ==========================================
    // HELPER FUNCTIONS
    // ==========================================
    
    // Check if user is authenticated
    function isAuthenticated() {
      return request.auth != null;
    }
    
    // Get authenticated user ID
    function getUserId() {
      return request.auth.uid;
    }
    
    // Check if user has specific role
    function hasRole(role) {
      return isAuthenticated() && 
             exists(/databases/$(database)/documents/users/$(getUserId())) &&
             get(/databases/$(database)/documents/users/$(getUserId())).data.role == role;
    }
    
    // Check if user is doctor
    function isDoctor() {
      return hasRole('doctor');
    }
    
    // Check if user is nurse
    function isNurse() {
      return hasRole('nurse');
    }
    
    // Check if user is medical staff (doctor or nurse)
    function isMedicalStaff() {
      return isDoctor() || isNurse();
    }
    
    // Check if user owns the resource
    function isOwner(resourceUserId) {
      return getUserId() == resourceUserId;
    }
    
    // Check if appointment belongs to the doctor
    function isAppointmentDoctor(appointmentData) {
      return isAuthenticated() && appointmentData.doctorId == getUserId();
    }
    
    // Validate email format
    function isValidEmail(email) {
      return email.matches('.*@.*\\..*');
    }
    
    // Validate medical license format (Romanian format)
    function isValidLicenseNumber(license) {
      return license.matches('[A-Z]{3}[0-9]{6}');
    }
    
    // Check if timestamp is recent (within last 5 minutes)
    function isRecentTimestamp(timestamp) {
      return timestamp > request.time - duration.value(5, 'm');
    }
    
    // Validate Romanian phone number
    function isValidPhoneNumber(phone) {
      return phone.matches('\\+40[0-9]{9}') || phone.matches('0[0-9]{9}');
    }
    
    // ==========================================
    // USER MANAGEMENT
    // ==========================================
    
    // Users collection - profile data
    match /users/{userId} {
      // Allow read access to own profile
      allow read: if isAuthenticated() && isOwner(userId);
      
      // Allow create during registration
      allow create: if isAuthenticated() && 
                       isOwner(userId) &&
                       isValidUserData(resource.data);
      
      // Allow update of own profile with validation
      allow update: if isAuthenticated() && 
                       isOwner(userId) &&
                       isValidUserUpdate(resource.data, request.data);
      
      // No delete allowed (for audit trail)
      allow delete: if false;
      
      // Validate user data structure
      function isValidUserData(data) {
        return data.keys().hasAll(['role', 'email', 'createdAt']) &&
               data.role in ['doctor', 'nurse'] &&
               isValidEmail(data.email) &&
               data.createdAt is timestamp;
      }
      
      // Validate user updates
      function isValidUserUpdate(currentData, newData) {
        return // Core fields cannot be changed
               newData.role == currentData.role &&
               newData.email == currentData.email &&
               newData.createdAt == currentData.createdAt &&
               // New data must include updatedAt
               newData.updatedAt is timestamp &&
               isRecentTimestamp(newData.updatedAt) &&
               // Optional fields validation
               (!('licenseNumber' in newData) || isValidLicenseNumber(newData.licenseNumber)) &&
               (!('phone' in newData) || isValidPhoneNumber(newData.phone)) &&
               // Prevent privilege escalation
               newData.role == currentData.role;
      }
    }
    
    // ==========================================
    // APPOINTMENTS MANAGEMENT
    // ==========================================
    
    // Appointments collection
    match /appointments/{appointmentId} {
      // Read access rules
      allow read: if isAuthenticated() && (
        // Doctor can read their own appointments
        isAppointmentDoctor(resource.data) ||
        // Nurses can read appointments from their clinic (if clinic field matches)
        (isNurse() && 'clinic' in resource.data && 'clinic' in get(/databases/$(database)/documents/users/$(getUserId())).data &&
         resource.data.clinic == get(/databases/$(database)/documents/users/$(getUserId())).data.clinic)
      );
      
      // Create appointment rules
      allow create: if isAuthenticated() && 
                       isMedicalStaff() &&
                       isValidAppointmentData(request.data) &&
                       // Only doctors can create appointments for themselves
                       (isDoctor() && request.data.doctorId == getUserId());
      
      // Update appointment rules
      allow update: if isAuthenticated() && 
                       isMedicalStaff() &&
                       isAppointmentDoctor(resource.data) &&
                       isValidAppointmentUpdate(resource.data, request.data);
      
      // Delete appointment rules (only doctors can delete their appointments)
      allow delete: if isAuthenticated() && 
                       isDoctor() && 
                       isAppointmentDoctor(resource.data);
      
      // Validate appointment data
      function isValidAppointmentData(data) {
        return data.keys().hasAll(['doctorId', 'patientName', 'dateTime', 'symptoms', 'status', 'createdAt']) &&
               data.doctorId is string &&
               data.patientName is string &&
               data.patientName.size() >= 2 &&
               data.patientName.size() <= 100 &&
               data.dateTime is timestamp &&
               data.dateTime > request.time &&
               data.symptoms is string &&
               data.symptoms.size() >= 10 &&
               data.symptoms.size() <= 2000 &&
               data.status in ['scheduled', 'completed', 'no_show'] &&
               data.createdAt is timestamp &&
               isRecentTimestamp(data.createdAt);
      }
      
      // Validate appointment updates
      function isValidAppointmentUpdate(currentData, newData) {
        return // Core fields cannot be changed
               newData.doctorId == currentData.doctorId &&
               newData.createdAt == currentData.createdAt &&
               // Must include updatedAt
               newData.updatedAt is timestamp &&
               isRecentTimestamp(newData.updatedAt) &&
               // Validate updated fields
               newData.patientName.size() >= 2 &&
               newData.patientName.size() <= 100 &&
               newData.symptoms.size() >= 10 &&
               newData.symptoms.size() <= 2000 &&
               newData.status in ['scheduled', 'completed', 'no_show'] &&
               // Notes validation if present
               (!('notes' in newData) || newData.notes.size() <= 1000);
      }
    }
    
    // ==========================================
    // DOCUMENT MANAGEMENT
    // ==========================================
    
    // Documents collection
    match /documents/{documentId} {
      // Read access rules
      allow read: if isAuthenticated() && (
        // Document uploader can read
        isOwner(resource.data.uploaderId) ||
        // Doctor who owns the appointment can read
        (isDoctor() && appointmentBelongsToDoctor(resource.data.appointmentId))
      );
      
      // Create document rules
      allow create: if isAuthenticated() && 
                       isMedicalStaff() &&
                       isValidDocumentData(request.data) &&
                       isOwner(request.data.uploaderId);
      
      // Update document metadata (limited updates allowed)
      allow update: if isAuthenticated() && 
                       isOwner(resource.data.uploaderId) &&
                       isValidDocumentUpdate(resource.data, request.data);
      
      // Delete document rules
      allow delete: if isAuthenticated() && 
                       isOwner(resource.data.uploaderId);
      
      // Check if appointment belongs to doctor
      function appointmentBelongsToDoctor(appointmentId) {
        return exists(/databases/$(database)/documents/appointments/$(appointmentId)) &&
               get(/databases/$(database)/documents/appointments/$(appointmentId)).data.doctorId == getUserId();
      }
      
      // Validate document data
      function isValidDocumentData(data) {
        return data.keys().hasAll(['appointmentId', 'uploaderId', 'fileUrl', 'fileName', 'contentType', 'size', 'createdAt']) &&
               data.appointmentId is string &&
               data.uploaderId == getUserId() &&
               data.fileUrl is string &&
               data.fileUrl.matches('https://firebasestorage\\.googleapis\\.com/.*') &&
               data.fileName is string &&
               data.fileName.size() >= 1 &&
               data.fileName.size() <= 255 &&
               data.contentType in ['application/pdf', 'image/jpeg', 'image/png', 'image/jpg'] &&
               data.size is number &&
               data.size > 0 &&
               data.size <= 10485760 && // 10MB limit
               data.createdAt is timestamp &&
               isRecentTimestamp(data.createdAt);
      }
      
      // Validate document updates (limited to metadata only)
      function isValidDocumentUpdate(currentData, newData) {
        return // Core fields cannot be changed
               newData.appointmentId == currentData.appointmentId &&
               newData.uploaderId == currentData.uploaderId &&
               newData.fileUrl == currentData.fileUrl &&
               newData.createdAt == currentData.createdAt &&
               // Only metadata can be updated
               newData.updatedAt is timestamp &&
               isRecentTimestamp(newData.updatedAt);
      }
    }
    
    // ==========================================
    // PATIENT REPORTS
    // ==========================================
    
    // Patient reports collection
    match /patient_reports/{reportId} {
      // Read access rules
      allow read: if isAuthenticated() && (
        // Doctor who created the report can read
        isOwner(resource.data.doctorId) ||
        // Nurses from same clinic can read finalized reports (if clinic field matches)
        (isNurse() && resource.data.status == 'final' && 
         'clinic' in resource.data && 'clinic' in get(/databases/$(database)/documents/users/$(getUserId())).data &&
         resource.data.clinic == get(/databases/$(database)/documents/users/$(getUserId())).data.clinic)
      );
      
      // Create report rules
      allow create: if isAuthenticated() && 
                       isDoctor() &&
                       isValidReportData(request.data) &&
                       request.data.doctorId == getUserId();
      
      // Update report rules
      allow update: if isAuthenticated() && 
                       isDoctor() &&
                       isOwner(resource.data.doctorId) &&
                       isValidReportUpdate(resource.data, request.data);
      
      // Delete report rules (only drafts can be deleted)
      allow delete: if isAuthenticated() && 
                       isDoctor() && 
                       isOwner(resource.data.doctorId) &&
                       resource.data.status == 'draft';
      
      // Validate report data
      function isValidReportData(data) {
        return data.keys().hasAll(['appointmentId', 'patientId', 'patientName', 'doctorId', 'doctorName', 'status', 'priority', 'createdAt', 'validation', 'auditTrail', 'gdprConsent']) &&
               data.appointmentId is string &&
               data.patientId is string &&
               data.patientName is string &&
               data.patientName.size() >= 2 &&
               data.patientName.size() <= 100 &&
               data.doctorId is string &&
               data.doctorName is string &&
               data.status in ['draft', 'final', 'archived'] &&
               data.priority in ['low', 'normal', 'high', 'urgent'] &&
               data.createdAt is timestamp &&
               isRecentTimestamp(data.createdAt) &&
               data.validation is map &&
               data.auditTrail is list &&
               data.gdprConsent is map &&
               data.gdprConsent.obtained == true &&
               data.gdprConsent.timestamp is timestamp;
      }
      
      // Validate report updates
      function isValidReportUpdate(currentData, newData) {
        return // Core fields cannot be changed
               newData.appointmentId == currentData.appointmentId &&
               newData.patientId == currentData.patientId &&
               newData.patientName == currentData.patientName &&
               newData.doctorId == currentData.doctorId &&
               newData.createdAt == currentData.createdAt &&
               newData.gdprConsent == currentData.gdprConsent &&
               // Must include updatedAt
               newData.updatedAt is timestamp &&
               isRecentTimestamp(newData.updatedAt) &&
               // Status transitions must be valid
               isValidStatusTransition(currentData.status, newData.status) &&
               // Validation and audit trail must be present
               newData.validation is map &&
               newData.auditTrail is list &&
               newData.auditTrail.size() > currentData.auditTrail.size();
      }
      
      // Validate status transitions
      function isValidStatusTransition(currentStatus, newStatus) {
        return // Draft can become final or archived
               (currentStatus == 'draft' && newStatus in ['draft', 'final', 'archived']) ||
               // Final can only become archived
               (currentStatus == 'final' && newStatus in ['final', 'archived']) ||
               // Archived cannot change
               (currentStatus == 'archived' && newStatus == 'archived');
      }
    }
    
    // ==========================================
    // REPORT TEMPLATES
    // ==========================================
    
    // Report templates collection
    match /report_templates/{templateId} {
      // Read access for all authenticated medical staff
      allow read: if isAuthenticated() && isMedicalStaff();
      
      // Create templates (doctors only)
      allow create: if isAuthenticated() && 
                       isDoctor() &&
                       isValidTemplateData(request.data) &&
                       request.data.createdBy == getUserId();
      
      // Update own templates
      allow update: if isAuthenticated() && 
                       isDoctor() &&
                       isOwner(resource.data.createdBy) &&
                       isValidTemplateUpdate(resource.data, request.data);
      
      // Delete own templates
      allow delete: if isAuthenticated() && 
                       isDoctor() && 
                       isOwner(resource.data.createdBy);
      
      // Validate template data
      function isValidTemplateData(data) {
        return data.keys().hasAll(['name', 'category', 'template', 'isPublic', 'createdBy', 'usage', 'tags', 'createdAt']) &&
               data.name is string &&
               data.name.size() >= 3 &&
               data.name.size() <= 100 &&
               data.category in ['general', 'specialty', 'emergency', 'routine'] &&
               data.template is map &&
               data.isPublic is bool &&
               data.createdBy is string &&
               data.usage is number &&
               data.usage >= 0 &&
               data.tags is list &&
               data.createdAt is timestamp &&
               isRecentTimestamp(data.createdAt);
      }
      
      // Validate template updates
      function isValidTemplateUpdate(currentData, newData) {
        return newData.createdBy == currentData.createdBy &&
               newData.createdAt == currentData.createdAt &&
               newData.updatedAt is timestamp &&
               isRecentTimestamp(newData.updatedAt);
      }
    }
    
    // ==========================================
    // VOICE TRANSCRIPTIONS
    // ==========================================
    
    // Voice transcriptions collection
    match /voice_transcriptions/{transcriptionId} {
      // Read access for report owner
      allow read: if isAuthenticated() && 
                     exists(/databases/$(database)/documents/patient_reports/$(resource.data.reportId)) &&
                     isOwner(get(/databases/$(database)/documents/patient_reports/$(resource.data.reportId)).data.doctorId);
      
      // Create transcriptions
      allow create: if isAuthenticated() && 
                       isDoctor() &&
                       isValidTranscriptionData(request.data);
      
      // Update transcription status
      allow update: if isAuthenticated() && 
                       isDoctor() &&
                       reportBelongsToDoctor(resource.data.reportId) &&
                       isValidTranscriptionUpdate(resource.data, request.data);
      
      // Delete transcriptions
      allow delete: if isAuthenticated() && 
                       isDoctor() && 
                       reportBelongsToDoctor(resource.data.reportId);
      
      // Check if report belongs to doctor
      function reportBelongsToDoctor(reportId) {
        return exists(/databases/$(database)/documents/patient_reports/$(reportId)) &&
               get(/databases/$(database)/documents/patient_reports/$(reportId)).data.doctorId == getUserId();
      }
      
      // Validate transcription data
      function isValidTranscriptionData(data) {
        return data.keys().hasAll(['reportId', 'transcript', 'confidence', 'language', 'processingStatus', 'createdAt']) &&
               data.reportId is string &&
               data.transcript is string &&
               data.confidence is number &&
               data.confidence >= 0 && data.confidence <= 1 &&
               data.language in ['ro', 'en'] &&
               data.processingStatus in ['pending', 'completed', 'failed'] &&
               data.createdAt is timestamp &&
               isRecentTimestamp(data.createdAt);
      }
      
      // Validate transcription updates
      function isValidTranscriptionUpdate(currentData, newData) {
        return newData.reportId == currentData.reportId &&
               newData.createdAt == currentData.createdAt &&
               newData.processingStatus in ['pending', 'completed', 'failed'] &&
               (newData.processingStatus != 'completed' || newData.processedAt is timestamp);
      }
    }
    
    // ==========================================
    // MONTHLY SUMMARIES
    // ==========================================
    
    // Monthly summaries collection
    match /monthly_summaries/{summaryId} {
      // Read access for the doctor who owns the summary
      allow read: if isAuthenticated() && isDoctor() && 
                     summaryId.matches('.*_.*') && 
                     summaryId.split('_')[0] == getUserId();
      
      // Allow create and update for summary caching
      allow create, update: if isAuthenticated() && isDoctor() && 
                              summaryId.matches('.*_.*') && 
                              summaryId.split('_')[0] == getUserId() &&
                              isValidMonthlySummaryData(request.data);
      
      // No deletion of summaries
      allow delete: if false;
      
      // Validate monthly summary data
      function isValidMonthlySummaryData(data) {
        return data.keys().hasAll(['month', 'totalReports', 'finalizedReports', 'readyForSubmission', 'submittedReports', 'lastUpdated']) &&
               data.month is string &&
               data.month.matches('[0-9]{4}-[0-9]{2}') &&
               data.totalReports is number &&
               data.totalReports >= 0 &&
               data.finalizedReports is number &&
               data.finalizedReports >= 0 &&
               data.readyForSubmission is number &&
               data.readyForSubmission >= 0 &&
               data.submittedReports is number &&
               data.submittedReports >= 0 &&
               data.lastUpdated is timestamp &&
               isRecentTimestamp(data.lastUpdated);
      }
    }
    
    // ==========================================
    // SUBMISSION BATCHES
    // ==========================================
    
    // Submission batches collection
    match /submission_batches/{batchId} {
      // Read access for the doctor who created the batch
      allow read: if isAuthenticated() && isDoctor() && 
                     isOwner(resource.data.createdBy);
      
      // Create submission batches
      allow create: if isAuthenticated() && isDoctor() &&
                       isValidSubmissionBatchData(request.data) &&
                       request.data.createdBy == getUserId();
      
      // Update submission batch status
      allow update: if isAuthenticated() && isDoctor() &&
                       isOwner(resource.data.createdBy) &&
                       isValidSubmissionBatchUpdate(resource.data, request.data);
      
      // No deletion of submission batches
      allow delete: if false;
      
      // Validate submission batch data
      function isValidSubmissionBatchData(data) {
        return data.keys().hasAll(['month', 'createdBy', 'createdAt', 'reportIds', 'status']) &&
               data.month is string &&
               data.month.matches('[0-9]{4}-[0-9]{2}') &&
               data.createdBy is string &&
               data.createdAt is timestamp &&
               isRecentTimestamp(data.createdAt) &&
               data.reportIds is list &&
               data.reportIds.size() > 0 &&
               data.reportIds.size() <= 500 &&
               data.status in ['preparing', 'ready', 'submitted', 'accepted', 'rejected'];
      }
      
      // Validate submission batch updates
      function isValidSubmissionBatchUpdate(currentData, newData) {
        return newData.month == currentData.month &&
               newData.createdBy == currentData.createdBy &&
               newData.createdAt == currentData.createdAt &&
               newData.reportIds == currentData.reportIds &&
               newData.status in ['preparing', 'ready', 'submitted', 'accepted', 'rejected'] &&
               isValidStatusTransitionBatch(currentData.status, newData.status);
      }
      
      // Validate batch status transitions
      function isValidStatusTransitionBatch(currentStatus, newStatus) {
        return // Preparing can become ready or submitted
               (currentStatus == 'preparing' && newStatus in ['preparing', 'ready', 'submitted']) ||
               // Ready can become submitted
               (currentStatus == 'ready' && newStatus in ['ready', 'submitted']) ||
               // Submitted can become accepted or rejected
               (currentStatus == 'submitted' && newStatus in ['submitted', 'accepted', 'rejected']) ||
               // Final states cannot change
               (currentStatus in ['accepted', 'rejected'] && newStatus == currentStatus);
      }
    }
    
    // ==========================================
    // AMENDMENT REQUESTS
    // ==========================================
    
    // Amendment requests collection
    match /amendment_requests/{requestId} {
      // Read access for the doctor who owns the related report
      allow read: if isAuthenticated() && isDoctor() && 
                     exists(/databases/$(database)/documents/patient_reports/$(resource.data.reportId)) &&
                     isOwner(get(/databases/$(database)/documents/patient_reports/$(resource.data.reportId)).data.doctorId);
      
      // Create amendment requests
      allow create: if isAuthenticated() && isDoctor() &&
                       isValidAmendmentRequestData(request.data) &&
                       request.data.requestedBy == getUserId();
      
      // Update amendment request status
      allow update: if isAuthenticated() && isDoctor() &&
                       reportBelongsToDoctor(resource.data.reportId) &&
                       isValidAmendmentRequestUpdate(resource.data, request.data);
      
      // No deletion of amendment requests
      allow delete: if false;
      
      // Validate amendment request data
      function isValidAmendmentRequestData(data) {
        return data.keys().hasAll(['reportId', 'requestedBy', 'requestedByRole', 'requestDate', 'reason', 'proposedChanges', 'status']) &&
               data.reportId is string &&
               data.requestedBy is string &&
               data.requestedByRole in ['doctor', 'nurse'] &&
               data.requestDate is timestamp &&
               isRecentTimestamp(data.requestDate) &&
               data.reason is string &&
               data.reason.size() >= 10 &&
               data.reason.size() <= 1000 &&
               data.proposedChanges is map &&
               data.status in ['pending', 'approved', 'rejected'];
      }
      
      // Validate amendment request updates
      function isValidAmendmentRequestUpdate(currentData, newData) {
        return newData.reportId == currentData.reportId &&
               newData.requestedBy == currentData.requestedBy &&
               newData.requestDate == currentData.requestDate &&
               newData.reason == currentData.reason &&
               newData.proposedChanges == currentData.proposedChanges &&
               newData.status in ['pending', 'approved', 'rejected'] &&
               isValidAmendmentStatusTransition(currentData.status, newData.status);
      }
      
      // Validate amendment status transitions
      function isValidAmendmentStatusTransition(currentStatus, newStatus) {
        return // Pending can become approved or rejected
               (currentStatus == 'pending' && newStatus in ['pending', 'approved', 'rejected']) ||
               // Final states cannot change
               (currentStatus in ['approved', 'rejected'] && newStatus == currentStatus);
      }
    }
    
    // ==========================================
    // REPORT VERSIONS
    // ==========================================
    
    // Report versions collection
    match /report_versions/{versionId} {
      // Read access for the doctor who owns the related report
      allow read: if isAuthenticated() && isDoctor() && 
                     resource.data.createdBy == getUserId();
      
      // Create report versions (system only)
      allow create: if isAuthenticated() && isDoctor() &&
                       isValidReportVersionData(request.data) &&
                       request.data.createdBy == getUserId();
      
      // No updates or deletions of versions
      allow update, delete: if false;
      
      // Validate report version data
      function isValidReportVersionData(data) {
        return data.keys().hasAll(['versionNumber', 'timestamp', 'createdBy', 'createdByRole', 'changes', 'reason', 'isActive']) &&
               data.versionNumber is number &&
               data.versionNumber > 0 &&
               data.timestamp is timestamp &&
               isRecentTimestamp(data.timestamp) &&
               data.createdBy is string &&
               data.createdByRole in ['doctor', 'nurse'] &&
               data.changes is map &&
               data.reason is string &&
               data.reason.size() >= 5 &&
               data.reason.size() <= 500 &&
               data.isActive is bool;
      }
    }
    
    // ==========================================
    // SUBMISSION QUEUE
    // ==========================================
    
    // Submission queue collection for processing government submissions
    match /submission_queue/{queueId} {
      // Read access for system monitoring (admin only)
      allow read: if isAuthenticated() && isAdmin();
      
      // Create queue items for batch processing
      allow create: if isAuthenticated() && isDoctor() &&
                       isValidSubmissionQueueData(request.data);
      
      // Update queue status during processing
      allow update: if isAuthenticated() && 
                       (isDoctor() && isValidQueueUpdate(resource.data, request.data)) ||
                       (isSystem() && isValidSystemQueueUpdate(resource.data, request.data));
      
      // No deletion of queue items (for audit purposes)
      allow delete: if false;
      
      // Validate submission queue data
      function isValidSubmissionQueueData(data) {
        return data.keys().hasAll(['batchId', 'priority', 'scheduledAt', 'createdAt', 'status', 'retryCount']) &&
               data.batchId is string &&
               data.priority in ['high', 'normal', 'low'] &&
               data.scheduledAt is timestamp &&
               data.createdAt is timestamp &&
               isRecentTimestamp(data.createdAt) &&
               data.status in ['pending', 'processing', 'completed', 'failed', 'cancelled'] &&
               data.retryCount is number &&
               data.retryCount >= 0 &&
               data.retryCount <= 10;
      }
      
      // Validate queue updates
      function isValidQueueUpdate(currentData, newData) {
        return newData.batchId == currentData.batchId &&
               newData.createdAt == currentData.createdAt &&
               newData.status in ['pending', 'processing', 'completed', 'failed', 'cancelled'] &&
               isValidQueueStatusTransition(currentData.status, newData.status);
      }
      
      // Validate system queue updates (more permissive for automation)
      function isValidSystemQueueUpdate(currentData, newData) {
        return newData.batchId == currentData.batchId &&
               newData.createdAt == currentData.createdAt &&
               newData.status in ['pending', 'processing', 'completed', 'failed', 'cancelled'];
      }
      
      // Validate queue status transitions
      function isValidQueueStatusTransition(currentStatus, newStatus) {
        return // Pending can become processing
               (currentStatus == 'pending' && newStatus in ['pending', 'processing', 'cancelled']) ||
               // Processing can become completed or failed
               (currentStatus == 'processing' && newStatus in ['processing', 'completed', 'failed']) ||
               // Failed can be retried (back to pending)
               (currentStatus == 'failed' && newStatus in ['failed', 'pending']) ||
               // Final states cannot change (except failed retry)
               (currentStatus in ['completed', 'cancelled'] && newStatus == currentStatus);
      }
    }
    
    // ==========================================
    // SUBMISSION RECEIPTS
    // ==========================================
    
    // Submission receipts collection
    match /submission_receipts/{receiptId} {
      // Read access for the doctor who owns the related batch
      allow read: if isAuthenticated() && isDoctor() && 
                     exists(/databases/$(database)/documents/submission_batches/$(resource.data.batchId)) &&
                     isOwner(get(/databases/$(database)/documents/submission_batches/$(resource.data.batchId)).data.createdBy);
      
      // Create receipts (system only after successful submission)
      allow create: if isAuthenticated() && isSystem() &&
                       isValidSubmissionReceiptData(request.data);
      
      // Update receipt status when government processes
      allow update: if isAuthenticated() && isSystem() &&
                       isValidReceiptUpdate(resource.data, request.data);
      
      // No deletion of receipts (permanent record)
      allow delete: if false;
      
      // Validate submission receipt data
      function isValidSubmissionReceiptData(data) {
        return data.keys().hasAll(['batchId', 'submissionId', 'governmentReference', 'confirmationId', 'submittedAt', 'submittedBy', 'reportCount', 'checksum', 'status']) &&
               data.batchId is string &&
               data.submissionId is string &&
               data.governmentReference is string &&
               data.confirmationId is string &&
               data.submittedAt is timestamp &&
               isRecentTimestamp(data.submittedAt) &&
               data.submittedBy is string &&
               data.reportCount is number &&
               data.reportCount > 0 &&
               data.checksum is string &&
               data.status in ['received', 'processing', 'accepted', 'rejected'];
      }
      
      // Validate receipt updates
      function isValidReceiptUpdate(currentData, newData) {
        return newData.batchId == currentData.batchId &&
               newData.submissionId == currentData.submissionId &&
               newData.governmentReference == currentData.governmentReference &&
               newData.submittedAt == currentData.submittedAt &&
               newData.submittedBy == currentData.submittedBy &&
               newData.status in ['received', 'processing', 'accepted', 'rejected'] &&
               isValidReceiptStatusTransition(currentData.status, newData.status);
      }
      
      // Validate receipt status transitions
      function isValidReceiptStatusTransition(currentStatus, newStatus) {
        return // Received can become processing
               (currentStatus == 'received' && newStatus in ['received', 'processing']) ||
               // Processing can become accepted or rejected
               (currentStatus == 'processing' && newStatus in ['processing', 'accepted', 'rejected']) ||
               // Final states cannot change
               (currentStatus in ['accepted', 'rejected'] && newStatus == currentStatus);
      }
    }
    
    // ==========================================
    // SUBMISSION LOGS
    // ==========================================
    
    // Submission logs collection for audit trail
    match /submission_logs/{logId} {
      // Read access for doctors who own related batches
      allow read: if isAuthenticated() && isDoctor() && 
                     exists(/databases/$(database)/documents/submission_batches/$(resource.data.batchId)) &&
                     isOwner(get(/databases/$(database)/documents/submission_batches/$(resource.data.batchId)).data.createdBy);
      
      // Create log entries (system and doctors)
      allow create: if isAuthenticated() && 
                       isValidSubmissionLogData(request.data) &&
                       (isSystem() || (isDoctor() && request.data.userId == getUserId()));
      
      // No updates or deletions of logs (immutable audit trail)
      allow update, delete: if false;
      
      // Validate submission log data
      function isValidSubmissionLogData(data) {
        return data.keys().hasAll(['timestamp', 'action', 'status', 'details']) &&
               data.timestamp is timestamp &&
               isRecentTimestamp(data.timestamp) &&
               data.action in ['created', 'queued', 'submitting', 'submitted', 'accepted', 'rejected', 'failed', 'retry_scheduled', 'retry_attempted', 'cancelled'] &&
               data.status is string &&
               data.details is string &&
               data.details.size() >= 5 &&
               data.details.size() <= 1000;
      }
    }
    
    // ==========================================
    // NOTIFICATION PREFERENCES
    // ==========================================
    
    // Notification preferences collection
    match /notification_preferences/{prefId} {
      // Read and write access for the user who owns the preferences
      allow read, write: if isAuthenticated() && resource.data.userId == getUserId();
      
      // Validate notification preferences data
      function isValidNotificationPrefsData(data) {
        return data.keys().hasAll(['userId', 'inApp', 'email', 'sms', 'push', 'submissionSuccess', 'submissionFailure', 'submissionRetry', 'updatedAt']) &&
               data.userId is string &&
               data.inApp is bool &&
               data.email is bool &&
               data.sms is bool &&
               data.push is bool &&
               data.submissionSuccess is bool &&
               data.submissionFailure is bool &&
               data.submissionRetry is bool &&
               data.updatedAt is timestamp &&
               isRecentTimestamp(data.updatedAt);
      }
    }
    
    // ==========================================
    // SUBMISSION NOTIFICATIONS
    // ==========================================
    
    // Submission notifications collection
    match /submission_notifications/{notificationId} {
      // Read access for the user who owns the notification
      allow read: if isAuthenticated() && resource.data.userId == getUserId();
      
      // Create notifications (system only)
      allow create: if isAuthenticated() && isSystem() &&
                       isValidSubmissionNotificationData(request.data);
      
      // Update to mark as read
      allow update: if isAuthenticated() && 
                       resource.data.userId == getUserId() &&
                       isValidNotificationUpdate(resource.data, request.data);
      
      // No deletion of notifications (for audit purposes)
      allow delete: if false;
      
      // Validate submission notification data
      function isValidSubmissionNotificationData(data) {
        return data.keys().hasAll(['userId', 'type', 'title', 'message', 'read', 'sent', 'createdAt', 'priority', 'urgent', 'gdprCompliant']) &&
               data.userId is string &&
               data.type in ['submission_success', 'submission_failure', 'submission_retry', 'submission_scheduled', 'period_reminder', 'manual_action_required'] &&
               data.title is string &&
               data.title.size() >= 5 &&
               data.title.size() <= 200 &&
               data.message is string &&
               data.message.size() >= 10 &&
               data.message.size() <= 1000 &&
               data.read is bool &&
               data.sent is bool &&
               data.createdAt is timestamp &&
               isRecentTimestamp(data.createdAt) &&
               data.priority in ['low', 'normal', 'high', 'critical'] &&
               data.urgent is bool &&
               data.gdprCompliant is bool &&
               data.gdprCompliant == true;
      }
      
      // Validate notification updates (only allow marking as read)
      function isValidNotificationUpdate(currentData, newData) {
        return newData.userId == currentData.userId &&
               newData.type == currentData.type &&
               newData.title == currentData.title &&
               newData.message == currentData.message &&
               newData.createdAt == currentData.createdAt &&
               newData.read is bool;
      }
    }
    
    // ==========================================
    // GOVERNMENT CONFIG
    // ==========================================
    
    // Government submission configuration (admin only)
    match /government_config/{configId} {
      // Read access for authenticated users
      allow read: if isAuthenticated() && isMedicalStaff();
      
      // Write access for admins only
      allow write: if isAuthenticated() && isAdmin();
    }
    
    // ==========================================
    // REPORT AUDIT LOGS
    // ==========================================
    
    // Report audit logs collection (write-only for security)
    match /report_audit_logs/{logId} {
      // No direct read access to audit logs via client
      allow read: if false;
      
      // Only system can write audit logs
      allow write: if false;
    }
    
    // ==========================================
    // MEDICAL RECORDS (Future expansion)
    // ==========================================
    
    // Medical records collection (placeholder for future use)
    match /medical_records/{recordId} {
      // Strict access control for medical records
      allow read, write: if false; // Disabled until proper implementation
      
      // TODO: Implement when medical records feature is added
      // - GDPR compliance checks
      // - Patient consent verification
      // - Medical professional licensing verification
      // - Audit logging for all access
    }
    
    // ==========================================
    // AUDIT LOGS
    // ==========================================
    
    // Audit logs collection (write-only for security)
    match /audit_logs/{logId} {
      // No read access to audit logs via client
      allow read: if false;
      
      // Only system can write audit logs
      allow write: if false;
    }
    
    // ==========================================
    // SYSTEM COLLECTIONS
    // ==========================================
    
    // System configuration (read-only for medical staff)
    match /system/{configId} {
      allow read: if isAuthenticated() && isMedicalStaff();
      allow write: if false; // Only admin can modify via server
    }
    
    // AI analysis results (read-only for document owners)
    match /ai_analysis/{analysisId} {
      allow read: if isAuthenticated() && 
                     exists(/databases/$(database)/documents/documents/$(resource.data.documentId)) &&
                     isOwner(get(/databases/$(database)/documents/documents/$(resource.data.documentId)).data.uploaderId);
      allow write: if false; // Only AI service can write
    }
    
    // ==========================================
    // DENY ALL OTHER ACCESS
    // ==========================================
    
    // Explicitly deny access to any other collections
    match /{document=**} {
      allow read, write: if false;
    }
  }
}
